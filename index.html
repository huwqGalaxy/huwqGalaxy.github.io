<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-test-blog-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/test-blog-1/" class="article-date">
  <time datetime="2019-12-10T03:23:03.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/test-blog-1/">test_blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>asdasdas</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/10/test-blog-1/" data-id="ck3zb2veo00003l3pwyaimd6w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-BeanFactory和FactoryBean、ApplicationContext的区别" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/BeanFactory和FactoryBean、ApplicationContext的区别/" class="article-date">
  <time datetime="2019-04-15T07:31:53.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/BeanFactory和FactoryBean、ApplicationContext的区别/">BeanFactory和FactoryBean、ApplicationContext的区别</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h6><p>BeanFactory是IOC最基本的容器，负责生产和管理bean，它在为其他具体的IOC容器提供了最基本的规范，例如XmlBeanFactory、ApplicationContext等具体的挺起都实现了BeanFactory，再在其基础上附加了其他功能<br><img src="https://img-blog.csdnimg.cn/20190415152958448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2ODc5ODcw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>BeanFactory源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory;  </span><br><span class="line">import org.springframework.beans.BeansException;  </span><br><span class="line">public interface BeanFactory &#123;  </span><br><span class="line">    String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;;  </span><br><span class="line">    Object getBean(String name) throws BeansException;  </span><br><span class="line">    &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException;  </span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException;  </span><br><span class="line">    Object getBean(String name, Object... args) throws BeansException;  </span><br><span class="line">    boolean containsBean(String name);  </span><br><span class="line">    boolean isSingleton(String name) throws NoSuchBeanDefinitionException;  </span><br><span class="line">    boolean isPrototype(String name) throws NoSuchBeanDefinitionException;  </span><br><span class="line">    boolean isTypeMatch(String name, Class&lt;?&gt; targetType) throws NoSuchBeanDefinitionException;  </span><br><span class="line">    Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException;  </span><br><span class="line">    String[] getAliases(String name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>BeanFactory，以Factory结尾，表示它是一个工厂类（接口），负责生产和管理bean的一个工厂。</li>
<li>在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。</li>
<li>BeanFactory只是一个接口，并不是IOC容器的具体实现，但是Spring容器给出了很多种实现。</li>
<li>BeanFacotry是spring中比较原始的Factory。如XMLBeanFactory就是一种典型的BeanFactory。</li>
<li>原始的BeanFactory无法支持spring的许多插件，如AOP功能、Web应用等</li>
<li>ApplicationContext接口,它由BeanFactory接口派生而来， <h6 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h6>BeanFactory是接口，提供了IIOC容器最基本的形式，给具体的IOC容器的实现提供了规范<br>FactoryBean也是一个接口，当在IOC容器中的Bean实现了FactoryBean后，通过getBean(String BeanName)获取到的Bean对象并不是FactoryBean的实现类对象，而是这个实现类中的getObject()方法返回的对象。要想获取FactoryBean的实现类，就要getBean(“&amp;”+BeanName)。通过重写getBean方法，我们可以实现简单工厂模式和装饰者模式<br>FactoryBean源码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.beans.factory;  </span><br><span class="line">public interface FactoryBean&lt;T&gt; &#123;  </span><br><span class="line">    T getObject() throws Exception;  </span><br><span class="line">    Class&lt;?&gt; getObjectType();  </span><br><span class="line">    boolean isSingleton();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>简单实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">xml</span><br><span class="line">&lt;bean id=&quot;student&quot; class=&quot;com.spring.bean.Student&quot;&gt;  </span><br><span class="line">  &lt;property name=&quot;name&quot; value=&quot;zhangsan&quot; /&gt;  </span><br><span class="line"> &lt;/bean&gt;  </span><br><span class="line"> </span><br><span class="line"> &lt;bean id=&quot;school&quot; class=&quot;com.spring.bean.School&quot;&gt;  </span><br><span class="line"> &lt;/bean&gt; </span><br><span class="line"> </span><br><span class="line"> &lt;bean id=&quot;factoryBeanPojo&quot; class=&quot;com.spring.bean.FactoryBeanPojo&quot;&gt;  </span><br><span class="line">    &lt;property name=&quot;type&quot; value=&quot;student&quot; /&gt;</span><br><span class="line"> &lt;/bean&gt; </span><br><span class="line"> </span><br><span class="line">public class FactoryBeanPojo implements FactoryBean&#123;</span><br><span class="line">	private String type;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public Object getObject() throws Exception &#123;</span><br><span class="line">		if(&quot;student&quot;.equals(type))&#123;</span><br><span class="line">			return new Student();			</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			return new School();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	@Override</span><br><span class="line">	public Class getObjectType() &#123;</span><br><span class="line">		return School.class;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public boolean isSingleton() &#123;</span><br><span class="line">		return true;</span><br><span class="line">    // settergetter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class School &#123;</span><br><span class="line">	private String schoolName;</span><br><span class="line">	private String address;</span><br><span class="line">	private int studentNumber;</span><br><span class="line">    // setter getter</span><br><span class="line">    // toString</span><br><span class="line">&#125;</span><br><span class="line">实现类</span><br><span class="line">ClassPathXmlApplicationContext cpxa = new ClassPathXmlApplicationContext(url);</span><br><span class="line">Object school=  cpxa.getBean(&quot;factoryBeanPojo&quot;);</span><br><span class="line">FactoryBeanPojo factoryBeanPojo= (FactoryBeanPojo) cpxa.getBean(&quot;&amp;factoryBeanPojo&quot;);</span><br><span class="line">System.out.println(school.getClass().getName());</span><br><span class="line">System.out.println(factoryBeanPojo.getClass().getName());</span><br><span class="line">输出</span><br><span class="line">com.spring.bean.Student</span><br><span class="line">com.spring.bean.FactoryBeanPojo</span><br></pre></td></tr></table></figure></p>
<p><strong>一般情况下，Spring通过反射机制利用bean标签中的class属性指定实现类实例化Bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式。则需要在<bean>中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个org.springframework.bean.factory.FactoryBean的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。FactoryBean接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个FactoryBean的实现。</bean></strong><br>它们隐藏了实例化一些复杂Bean的细节，给上层应用带来了便利。从Spring3.0开始，FactoryBean开始支持泛型，即接口声明改为FactoryBean<t>的形式。<br>以Bean结尾，表示它是一个Bean，不同于普通Bean的是：它是实现了FactoryBean<t>接口的Bean，根据该Bean的ID从BeanFactory中获取的实际上是FactoryBean的getObject()返回的对象，而不是FactoryBean本身，如果要获取FactoryBean对象，请在id前面加一个&amp;符号来获取。<br>参考：<br><a href="https://www.cnblogs.com/aspirant/p/9082858.html" target="_blank" rel="noopener">BeanFactory 简介以及它 和FactoryBean的区别(阿里面试)</a><br><a href="https://blog.csdn.net/wangbiao007/article/details/53183764" target="_blank" rel="noopener">BeanFactory和FactoryBean的区别</a></t></t></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/15/BeanFactory和FactoryBean、ApplicationContext的区别/" data-id="ck3zb2vex00033l3pqcypdx9h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/11/工厂模式/" class="article-date">
  <time datetime="2019-04-11T14:55:32.000Z" itemprop="datePublished">2019-04-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/11/工厂模式/">工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="工厂模式的分类"><a href="#工厂模式的分类" class="headerlink" title="工厂模式的分类"></a>工厂模式的分类</h5><ol>
<li>简单工厂模式<ol>
<li>JDK类库，如工具类java.text.DateFormat</li>
<li>java加密技术</li>
<li>spring-BeanFactory</li>
</ol>
</li>
<li>工厂方法模式<ol>
<li>JDBC</li>
<li>spring-FactoryBean</li>
</ol>
</li>
<li>抽象工厂模式</li>
</ol>
<h5 id="为什么要用工厂模式"><a href="#为什么要用工厂模式" class="headerlink" title="为什么要用工厂模式"></a>为什么要用工厂模式</h5><ol>
<li>解耦：把对象的创建和使用的过程分开</li>
<li>降低代码重复：如果创建某个对象的过程很复杂，而且使用率很高，那么就会有很多重复代码</li>
<li>降低维护成本：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有创建该对象的地方逐个修改，只需要在工厂里修改即可<br>spring中的BeanFactory，根据传入一个唯一的标识来获得bean对象</li>
</ol>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p>严格来说简单工厂模式并不是23种常用的设计模式之一，他只算工厂模式的一个特殊实现。<br>适用场景：<br>1.需要创建的对象较少<br>2.客户端不关心对象的创建过程，只需要知道传入的参数</p>
<h6 id="角色分配"><a href="#角色分配" class="headerlink" title="角色分配"></a>角色分配</h6><ol>
<li>工厂角色Factory：简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象</li>
<li>抽象产品角色Product：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口</li>
<li>具体产品角色Concrete Product：简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例</li>
</ol>
<h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p>创建一个绘图工具<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">总的接口</span><br><span class="line">public interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br><span class="line">图形类</span><br><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    public Circle() &#123;</span><br><span class="line">        System.out.println(&quot;Circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Draw Circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line">    public Rectangle() &#123;</span><br><span class="line">        System.out.println(&quot;Rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Draw Rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Square implements Shape &#123;</span><br><span class="line">    public Square() &#123;</span><br><span class="line">        System.out.println(&quot;Square&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Draw Square&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">工厂类</span><br><span class="line">public class ShapeFactory &#123;</span><br><span class="line"></span><br><span class="line">    // 使用 getShape 方法获取形状类型的对象</span><br><span class="line">    public static Shape getShape(String shapeType) &#123;</span><br><span class="line">        if (shapeType == null) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;)) &#123;</span><br><span class="line">            return new Circle();</span><br><span class="line">        &#125; else if (shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;)) &#123;</span><br><span class="line">            return new Rectangle();</span><br><span class="line">        &#125; else if (shapeType.equalsIgnoreCase(&quot;SQUARE&quot;)) &#123;</span><br><span class="line">            return new Square();</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样子就实现了一个简单工厂。<br>但如果新增产品类的话（即新增一种图形），就需要修改工厂类中的getShape方法，这很明显不符合开放-封闭原则。</p>
<h6 id="使用反射机制改善简单工厂"><a href="#使用反射机制改善简单工厂" class="headerlink" title="使用反射机制改善简单工厂"></a>使用反射机制改善简单工厂</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory2 &#123;</span><br><span class="line">    public static Object getClass(Class&lt;? extends Shape&gt; clazz) &#123;</span><br><span class="line">        Object obj = null;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            obj = Class.forName(clazz.getName()).newInstance();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape circle = (Shape) ShapeFactory2.getShape(com.example.demo.factory.Circle.class);</span><br></pre></td></tr></table></figure>
<p>这样新增产品类是就不需要修改产品工厂的方法了，但是每次传入全路径名。可以将全路径名存储在配置文件中简化代码。</p>
<h6 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h6><ol>
<li>三个角色：<ol>
<li>工厂角色负责实现创建所有实例的内部逻辑</li>
<li>抽象产品角色是所有创建对象的父类，负责描述是所有实例所公有的公共接口</li>
<li>具体产品角色是创建目标</li>
</ol>
</li>
<li>当你需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，无须知道创建细节</li>
<li>最大优点：对象的创建和使用分离</li>
<li>缺点：不够灵活</li>
</ol>
<h5 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式 Factory Method"></a>工厂方法模式 Factory Method</h5><p>将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类称为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口。这样进一步抽象化的好处是使得系统在不修改具体工厂角色的情况下引进新的产品。<br>spring FactoryBean</p>
<h6 id="工厂方法模式角色分配"><a href="#工厂方法模式角色分配" class="headerlink" title="工厂方法模式角色分配"></a>工厂方法模式角色分配</h6><ol>
<li>抽象工厂角色（Abstract Factory）：工厂方法模式的核心，与应用程序无关。任何在这个模式中创建对象的工厂类必须实现这个接口</li>
<li>具体工厂角色（Concrete Factory）：实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象</li>
<li>抽象产品角色（Abstract Product）：工厂方法模式所创建对象的超类型</li>
<li>具体产品角色（Concrete Product）：实现了抽象角色所定义的接口。每个具体产品角色都有专门的具体工厂创建。一一对应。<h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">抽象产品角色</span><br><span class="line"> interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br><span class="line">具体产品角色</span><br><span class="line"> class Circle implements Shape &#123;</span><br><span class="line">    public Circle() &#123;</span><br><span class="line">        System.out.println(&quot;Circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Draw Circle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> class Rectangle implements Shape &#123;</span><br><span class="line">    public Rectangle() &#123;</span><br><span class="line">        System.out.println(&quot;Rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;Draw Rectangle&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">抽象工厂角色</span><br><span class="line">interface ShapeFactoryMethod&#123;</span><br><span class="line">    Shape getShape();</span><br><span class="line">&#125;</span><br><span class="line">具体工厂角色</span><br><span class="line">class CircleFactory implements  ShapeFactoryMethod&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape() &#123;</span><br><span class="line">        return new Circle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class RectangleFactory implements  ShapeFactoryMethod&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Shape getShape() &#123;</span><br><span class="line">        return new Rectangle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ShapeFactoryMethod circleFactory = new CircleFactory();</span><br><span class="line">Shape shape = circleFactory.getShape();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>其实就是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现开放-封闭原则，实现了可扩展。其次更复杂的层次结构，可以应用于产品结果复杂的场合。<br>但当产品种类非常多时，就会出现大量的与之对应的工厂类。</p>
<h6 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h6><ol>
<li>使用了OOP的多态性，可信工厂类不再负责创建，而是交给子类去做，克服了简单工厂的缺点</li>
<li>缺点：增加新产品时系统类的个数成对增加，增加了系统的复杂度</li>
<li>扩展：产品对象的复用：工厂对象将已经创建过的产品保存到一个集合中，然后根据需求对集合进行查询，如果有就直接返回，如果没有则创建之后添加到结合中再返回</li>
</ol>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p>提供一个创建一系列相关或相互依赖对象的接口，而无须指定他们具体的类。</p>
<h6 id="角色分配-1"><a href="#角色分配-1" class="headerlink" title="角色分配"></a>角色分配</h6><ol>
<li>抽象工厂角色</li>
<li>具体工厂类角色</li>
<li>抽象产品角色</li>
<li>具体产品角色<h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">interface Bullets&#123;</span><br><span class="line">    void produceBullets();</span><br><span class="line">&#125;</span><br><span class="line">class Ak_Bullets implements  Bullets&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void produceBullets() &#123;</span><br><span class="line">        System.out.println(&quot;produce 7.62mm bullets&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class M4_Bullets implements Bullets&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void produceBullets() &#123;</span><br><span class="line">        System.out.println(&quot;produce 5.56mm bullets&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Gun&#123;</span><br><span class="line">    void produceGun();</span><br><span class="line">&#125;</span><br><span class="line">class AK47 implements Gun&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void produceGun() &#123;</span><br><span class="line">        System.out.println(&quot;produce AK47&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class M4A1 implements Gun&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void produceGun() &#123;</span><br><span class="line">        System.out.println(&quot;product M4A1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface AbstractFireFactory&#123;</span><br><span class="line">    Gun produceGun();</span><br><span class="line">    Bullets produceBullets();</span><br><span class="line">&#125;</span><br><span class="line">class AkFactory implements AbstractFireFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Gun produceGun() &#123;</span><br><span class="line">        return new AK47();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bullets produceBullets() &#123;</span><br><span class="line">        return new Ak_Bullets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class M4Factory implements  AbstractFireFactory&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Gun produceGun() &#123;</span><br><span class="line">        return new M4A1();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bullets produceBullets() &#123;</span><br><span class="line">        return new M4_Bullets();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">AbstractFireFactory aff = new AkFactory();</span><br><span class="line">Gun gun = aff.produceGun();</span><br><span class="line">Bullets bullets = aff.produceBullets();</span><br><span class="line">gun.produceGun();</span><br><span class="line">bullets.produceBullets();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="抽象工厂中的工厂与工厂方法中的工厂的区别"><a href="#抽象工厂中的工厂与工厂方法中的工厂的区别" class="headerlink" title="抽象工厂中的工厂与工厂方法中的工厂的区别"></a>抽象工厂中的工厂与工厂方法中的工厂的区别</h6><p>抽象工厂是生成一整套有产品的（至少要生产两个产品），这些产品必须相互室友关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂</p>
<h6 id="开放封闭原则的倾斜性"><a href="#开放封闭原则的倾斜性" class="headerlink" title="开放封闭原则的倾斜性"></a>开放封闭原则的倾斜性</h6><ol>
<li>“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：<ol>
<li>增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。</li>
<li>增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。</li>
</ol>
</li>
<li>抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。</li>
</ol>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><ol>
<li>主要优点：隔离了具体类的生成，使得客户并不需要知道什么被创建而且每次可以通过具体工厂类创建一个产品族中的多个产品，增加或替换产品族比较方便，增加新的具体工厂和产品族很方便</li>
<li>主要缺点：增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对开放封闭原则的支持成倾斜性</li>
</ol>
<p>参考<br><a href="https://segmentfault.com/a/1190000015050674" target="_blank" rel="noopener">深入理解工厂模式</a><br><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/simple_factory.html" target="_blank" rel="noopener">创建型模式</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/11/工厂模式/" data-id="ck3zb2vf700063l3p7k1e4tyh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-静态代理、JDK动态代理、CgLib动态代理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/静态代理、JDK动态代理、CgLib动态代理/" class="article-date">
  <time datetime="2019-04-10T12:41:00.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/静态代理、JDK动态代理、CgLib动态代理/">静态代理、JDK动态代理、CgLib动态代理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>代理模式：</p>
<ol>
<li>静态代理</li>
<li>动态代理<ol>
<li>jdk动态代理</li>
<li>cgLib动态代理<br>使用目的：解决在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面对对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问，直接访问会给使用者或者系统结构带来很多麻烦</li>
</ol>
</li>
</ol>
<p>每一个动态代理类中都必须实现Invocation接口，实现其中的invoke方法<br>JDK的动态代理必须需要目标对象实现接口，否则不能生成代理对象<br>UserServiceImpl implements UserService</p>
<h5 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h5><p>静态代理方式是为每个被代理的对象构造对应的代理类。在程序运行前，代理类的class文件已经存在了。但是一个代理类对应一个被代理对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public interface UserService &#123;</span><br><span class="line">    void addUser();</span><br><span class="line">&#125;</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void addUser() &#123;</span><br><span class="line">        System.out.println(&quot;添加一名用户&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StaticProxy implements UserService&#123;</span><br><span class="line"></span><br><span class="line">    private UserServiceImpl userServiceImpl;</span><br><span class="line"></span><br><span class="line">    public StaticProxy(UserServiceImpl userServiceImpl) &#123;</span><br><span class="line">        this.userServiceImpl = userServiceImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addUser() &#123;</span><br><span class="line">        System.out.println(&quot;运行方法前日志&quot;);</span><br><span class="line">        userServiceImpl.addUser();</span><br><span class="line">        System.out.println(&quot;运行方法后日志&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class StaticProxyFactory &#123;</span><br><span class="line">    public static StaticProxy newInstance()&#123;</span><br><span class="line">        return new StaticProxy(new UserServiceImpl());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">调用时</span><br><span class="line">StaticProxy staticProxy = StaticProxyFactory.newInstance();</span><br><span class="line">staticProxy.addUser();</span><br></pre></td></tr></table></figure></p>
<p>这种方式是继承同一个接口，然后内部维护了一个实现类，也可以直接继承该实现类，方法实现用super调用。<br>优点：业务类只需要关注业务逻辑本身，保证了业务类的重用性。这是代理模式的共有优点<br>缺点：</p>
<ol>
<li>代理对象的一个接口只服务于一种类型的对象，如果要代理的类型很多，势必要为每一种类型的方法都进行代理</li>
<li>如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。</li>
</ol>
<p>和装饰设计模式的核心区别：<br>    装设设计模式是对被装饰者对象执行结果(map)的处理<br>    而静态代理是在调用委托类对象方法执行前后做一些其他操作</p>
<h5 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h5><p>动态代理是在实现阶段不用关心代理类，而在运行阶段才指定哪一个对象。invoke方法采用回调的方式执行，只有在代理对象执行方法时，才会被invoke拦截</p>
<h6 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h6><p>JDK动态代理所用到的代理类在程序调用到代理类对象时才由JVM真正创建，JVM根据传进来的 业务实现类对象 以及 方法名 ，动态地创建了一个代理类的class文件并被字节码引擎执行，然后通过该代理类对象进行方法调用。<br>实现步骤</p>
<ol>
<li>创建被代理的类以及实现的接口</li>
<li>创建一个实现接口InvocationHandler的类，必须实现invoke方法</li>
<li>调用Proxy的newProxyInstance静态方法，创建一个代理类</li>
<li>通过代理对象调用目标方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Hello &#123;</span><br><span class="line">    void sayHello();</span><br><span class="line">&#125;</span><br><span class="line">class HelloImpl implements Hello &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void sayHello() &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class MyInvocationHandler implements InvocationHandler &#123;</span><br><span class="line">    private Object target;</span><br><span class="line"></span><br><span class="line">    public MyInvocationHandler(Object target) &#123;</span><br><span class="line">        this.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;method :&quot; + method.getName() + &quot; is invoked!&quot;);</span><br><span class="line">        return method.invoke(target, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">main&#123;</span><br><span class="line">    Hello helloWorld = (Hello) Proxy.</span><br><span class="line">        newProxyInstance(JDKProxyTest.class.getClassLoader(),</span><br><span class="line">                new Class&lt;?&gt;[]&#123;Hello.class&#125;,</span><br><span class="line">                new MyInvocationHandler(new HelloImpl()));</span><br><span class="line">helloWorld.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现InvocationHandler接口步骤</p>
<ol>
<li>定义含参构造方法，该参数为要代理的实例对象，目的是用于执行method.invoke()方法(也就是执行目标方法)</li>
<li>实现接口的invoke()方法，该方法用于对目标方法的增强处理，比如记录日志等。该方法的返回值就是代理对象执行目标方法的返回值</li>
</ol>
<p>具体参数</p>
<ol>
<li>proxy 动态dialing生成的代理对象</li>
<li>method 目标方法的实例</li>
<li><p>args 目标方法的参数<br>通过Proxy.newProxyInstance方法生成代理对象，具体参数有</p>
</li>
<li><p>loader目标类的类加载器</p>
</li>
<li>interfaces 目标类实现的接口</li>
<li>InvocationHandler 调用处理类的实现对象</li>
</ol>
<p>注意点：JDK的动态代理只能代理实现了接口的类</p>
<h6 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h6><p>cglib是针对类来实现代理的，原理是通过字节码对指定的业务类生成一个子类，并覆盖其中业务方法实现代理，顺势织入横切逻辑。因为采用的是继承，所以不能对final修饰的类进行代理。<br>需要引入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">   &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">   &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt;</span><br><span class="line">   &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//代理类</span><br><span class="line">public class UserServiceCglibMethodInterceptor implements MethodInterceptor &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">		System.out.println(&quot;Cglib Before add&quot;);</span><br><span class="line">		Object result = methodProxy.invokeSuper(object, objects);</span><br><span class="line">		System.out.println(&quot;Cglib After add&quot;);</span><br><span class="line">		return result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理工厂</span><br><span class="line">public class ProxyCglibFactory &#123;</span><br><span class="line"></span><br><span class="line">	public static UserService getInstance() &#123;</span><br><span class="line">		Enhancer enhancer = new Enhancer();  </span><br><span class="line">		enhancer.setSuperclass(UserServiceImpl.class);  </span><br><span class="line">		enhancer.setCallback(new UserServiceCglibMethodInterceptor());  </span><br><span class="line">		return (UserServiceImpl)enhancer.create();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line">//测试</span><br><span class="line">public class TestCglibProxy &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		UserService userService = ProxyCglibFactory.getInstance();</span><br><span class="line">		User user = new User();</span><br><span class="line">		user.setId(12);</span><br><span class="line">		user.setName(&quot;哈哈&quot;);</span><br><span class="line">		user.setAge(23);</span><br><span class="line">		userService.add(user);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代理对象的生成过程由Enhancer类实现，大致步骤如下</p>
<ol>
<li>生成代理类Class的二进制字节码</li>
<li>通过Class.foName加载二进制字节码，生成Class对象</li>
<li>通过反射机制获取实例构造，并初始化代理类对象</li>
</ol>
<p>特点</p>
<ol>
<li>cglib的动态代理是针对类来实现代理</li>
<li>对指定目标类产生一个子类，通过方法拦截技术拦截所有父类方法的调用</li>
<li>因为是通过集成实现，final类无法使用cglib</li>
</ol>
<p>总结JDKProxy和CgLibProxy的区别</p>
<ol>
<li>jdk动态代理生成的代理类和委托类实现了相同的接口</li>
<li>cglib动态代理中生成的字节码更加复杂，生成的代理类是委托类的子类，且不能处理被final修饰的类</li>
<li>jdk采用反射机制调用委托类的方法，cglib采用类似索引的方式直接调用委托类方法</li>
<li>jdk利用jdk的API，动态的再内存中构建代理对象</li>
<li>cglib在内存中构建一个子类对象</li>
<li>JDK动态代理生成的类为com.sun.proxy.$Proxy0</li>
<li>cglib生成的类为class.cglib.委托类接口$$EnhancerByCGLIB$$552188b6<br><strong><em>JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</em></strong></li>
</ol>
<p>参考<br><a href="https://juejin.im/entry/5989712f6fb9a03c4c26fb3a" target="_blank" rel="noopener">JAVA中的静态代理、动态代理以及CGLIB动态代理</a><br><a href="my.oschina.net/robinyao/blog/811193">JDK动态代理详解</a><br><a href="http://1csh1.github.io/2017/02/20/Java%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/" target="_blank" rel="noopener">Java的静态代理和动态代理</a><br><a href="https://juejin.im/entry/5989712f6fb9a03c4c26fb3a" target="_blank" rel="noopener">JAVA中的静态代理、动态代理以及CGLIB动态代理</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&amp;mid=2247484707&amp;idx=1&amp;sn=b0fc5846e4b5f9c9a7ef1480a48e80ae&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">深入理解［代理模式］原理与技术</a><br><a href="https://segmentfault.com/a/1190000011291179#articleHeader3" target="_blank" rel="noopener">Java三种代理模式：静态代理、动态代理和cglib代理</a><br><a href="jianshu.com/p/269afd0a52e6">JDK动态代理-超详细源码分析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/10/静态代理、JDK动态代理、CgLib动态代理/" data-id="ck3zb2vf500043l3pqaapcwr2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-java内存模型JMM" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/08/java内存模型JMM/" class="article-date">
  <time datetime="2019-04-08T13:00:05.000Z" itemprop="datePublished">2019-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/08/java内存模型JMM/">java内存模型JMM</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h5 id="内存模型抽象结构"><a href="#内存模型抽象结构" class="headerlink" title="内存模型抽象结构"></a>内存模型抽象结构</h5><p>线程间协作通信可以类比人与人之间的协作的方式，在现实生活中，之前网上有个流行语“你妈喊你回家吃饭了”，就以这个生活场景为例，小明在外面玩耍，小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：<br>小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条“饭做好了，放在…”小明回家后看到纸条如愿吃到妈妈做的饭菜，那么，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的<u><em>共享变量</em></u> ，通过读写共享变量实现两个线程间协作；<br>还有一种方式就是，妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到<u><em>线程间通信机制</em></u>。<br>通过上面这个例子，应该有些认识。在并发编程中主要需要解决两个问题：<u><em>1. 线程之间如何通信；2.线程之间如何完成同步</em></u>（这里的线程指的是并发执行的活动实体）。通信是指线程之间以何种机制来交换信息，主要有两种：共享内存和消息传递。这里，可以分别类比上面的两个举例。java内存模型是共享内存的并发模型，线程之间主要通过读-写共享变量来完成隐式通信。</p>
<h6 id="哪些是共享变量"><a href="#哪些是共享变量" class="headerlink" title="哪些是共享变量"></a>哪些是共享变量</h6><p>java中所有的实例域、静态域和数组元素都是放在堆内存中（所有线程均可访问，是共享的）。而局部遍历，方法定义参数和异常处理参数不会再线程间共享（栈私有）</p>
<h6 id="JMM抽象模型"><a href="#JMM抽象模型" class="headerlink" title="JMM抽象模型"></a>JMM抽象模型</h6><p><a href="http://wx4.sinaimg.cn/large/0060lm7Tly1g1viv9krnhj30rs0nkn2j.jpg" target="_blank" rel="noopener">http://wx4.sinaimg.cn/large/0060lm7Tly1g1viv9krnhj30rs0nkn2j.jpg</a><br>因为CPU的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU都会有缓存。因此共享变量会先放在主存中，每个线程都有属于自己的工作内存，并且会把主存中的共享变量拷贝到自己的工作内中，并在某个时刻将工作内存的变量副本写回到主存中。<br>由此线程A要与线程B完成通信的话要经过如下操作<br>1.线程A从主存中拷贝共享变量进行操作，之后将数据重新写入到主存<br>2.线程B从主存获取最新的共享变量值</p>
<h6 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h6><p>在不改变程序执行结果的前提下，尽可能的提高并行度。因此为了提高性能，编译器和处理器常常会对指令进行重排序<br><a href="http://wx2.sinaimg.cn/large/0060lm7Tly1g1vj0bytsrj318o05w0vc.jpg" target="_blank" rel="noopener">http://wx2.sinaimg.cn/large/0060lm7Tly1g1vj0bytsrj318o05w0vc.jpg</a><br>一般重排序分为以下三种</p>
<ol>
<li>编译器重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序。现在处理器采用了指令级并行技术来将多条指令折叠执行。<strong><em>如果不存在数据依赖性</em></strong>，处理器可以改变语句对应机器指令的执行顺序</li>
<li>内存系统的重排序。由于处理器采用缓存和读、写缓冲区，这使得加载和存储操作看上去是在乱序执行。<br>2、3同属于处理器重排序<br><u><strong><em>针对编译器重排序，JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障来禁止某些特殊的处理器重排序</em></strong></u><h6 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h6>定义：如果两个操作访问同一个变量，且其中一个为写操作，此时这两个操作就存在数据依赖性<br>例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double pi = 3.14 //A</span><br><span class="line"></span><br><span class="line">double r = 1.0 //B</span><br><span class="line"></span><br><span class="line">double area = pi * r * r //C</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这是一个计算圆面积的代码，其中AB没有任何关系，对最终结果也不会造成影响，因此他们之间的执行顺序可以重排序，所以执行顺序可以使A-B-C或B-A-C<br>编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序</p>
<h6 id="as-if-serial"><a href="#as-if-serial" class="headerlink" title="as-if-serial"></a>as-if-serial</h6><p>as-if-serial语义的意思是不管怎么重排序，（单线程）程序的执行结果不能被改变。<br>编译器和处理器都必须遵守as-if-serial语义。这产生了一种程序按顺序执行的错觉</p>
<h6 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h6><p>JMM提供了八条规则，去推论跨线程的内存可见性问题问题</p>
<ol>
<li>程序顺序规则：一个线程的每个操作，happens-before于该线程的任意后续操作</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于这个锁的加锁</li>
<li>volatile规则：对一个volatile域的写，happens-before于后续任意对这个volatile域的读</li>
<li>传递性：如果A happens-before于B，B happens-before于C，那么A happens-before于C</li>
<li>start()规则：如果线程A内启动线程B，那么ThreadB.start() happens-before于B内的任何操作</li>
<li>join()规则：如果线程A执行线程B的join操作并成功返回，那么线程B内的所有操作都happens-before于返回操作</li>
<li>程序终端规则：对对象的interrupt操作happens-before于被中断代码检测到中断事件的发生</li>
<li>对象终结规则：一个对象初始化happen-before于finalize<h6 id="as-if-serial和happens-before的区别"><a href="#as-if-serial和happens-before的区别" class="headerlink" title="as-if-serial和happens-before的区别"></a>as-if-serial和happens-before的区别</h6>就是as-if-serial是保证单线程执行结果不改变的，而happens-before保证正确同步的多线程的执行结果不被改变</li>
</ol>
<h6 id="重排序案例"><a href="#重排序案例" class="headerlink" title="重排序案例"></a>重排序案例</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int x = 0;</span><br><span class="line">static int y = 0;</span><br><span class="line">static int a = 0;</span><br><span class="line">static int b = 0;</span><br><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">    x = 0;y=0;a=0;b=0;</span><br><span class="line">    for (int i = 0; i &lt; 100; i++) &#123;</span><br><span class="line">        Thread one = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                a = 1;//1</span><br><span class="line">                x = b;//2</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Thread two = new Thread() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                b = 1;//3</span><br><span class="line">                y = a;//4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        one.start();</span><br><span class="line">        two.start();</span><br><span class="line">        System.out.println(x + &quot; &quot; + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能得到结果(1,0),(1,1),(0,1)，事实上按照JMM的特性还可能得到(0,0)<br>其中1、2和3、4之间没有数据依赖符合as-if-serial原则,因此存在重排序，即2先于1执行，4先于3执行，而又由于多线程并发执行，最后执行顺序可能为4213(只要24都先于13)时，结果为(0,0)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/08/java内存模型JMM/" data-id="ck3zb2vev00023l3px99ihom8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-test-blog" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/07/test-blog/" class="article-date">
  <time datetime="2019-04-06T17:52:05.000Z" itemprop="datePublished">2019-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/07/test-blog/">test_blog</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>JMM<br><img src="evernotecid://D7D93712-3C2E-4EC3-AA0B-D1A7842C2B81/appyinxiangcom/21861001/ENResource/p178" alt="9d9d7def0c3e7815c920ff5b54d576d3.png"></p>
<h6 id="并发三大性质"><a href="#并发三大性质" class="headerlink" title="并发三大性质"></a>并发三大性质</h6><ul>
<li>原子性</li>
<li>可见性</li>
<li>有序性<br>原子性：一个操作不可中断，要么全部执行成功，要么全部执行不成功。提供了互斥访问，同一时刻只能有一个线程来对它进行操作。<br>可见性：当一个线程修改了主内存的共享变量后能够及时的被其他线程观察到<br>有序性：synchronize语义要求线程在访问读写共享变量时只能”串行”执行，因此Synchronize具有有序性。<br>为了性能优化，编译器和处理器会进行指令重排序，因此如果在本线程内观察，所有操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的<h6 id="临界区：同一时刻只能有一个任务访问的代码区"><a href="#临界区：同一时刻只能有一个任务访问的代码区" class="headerlink" title="临界区：同一时刻只能有一个任务访问的代码区"></a>临界区：同一时刻只能有一个任务访问的代码区</h6>互斥量：是一个可以处于两态之一的变量：解锁和加锁<h6 id="信号量Semaphore：又称信号灯，用来在多线程环境下，用来保证两个或多个关键代码不被并发调用。在进入一个关键代码段全必须获取一个信号量，一旦关键代码完成，线程必须释放信号量。其他想要进入该关键代码段的线程必须等待第一个线程释放该信号量。"><a href="#信号量Semaphore：又称信号灯，用来在多线程环境下，用来保证两个或多个关键代码不被并发调用。在进入一个关键代码段全必须获取一个信号量，一旦关键代码完成，线程必须释放信号量。其他想要进入该关键代码段的线程必须等待第一个线程释放该信号量。" class="headerlink" title="信号量Semaphore：又称信号灯，用来在多线程环境下，用来保证两个或多个关键代码不被并发调用。在进入一个关键代码段全必须获取一个信号量，一旦关键代码完成，线程必须释放信号量。其他想要进入该关键代码段的线程必须等待第一个线程释放该信号量。"></a>信号量Semaphore：又称信号灯，用来在多线程环境下，用来保证两个或多个关键代码不被并发调用。在进入一个关键代码段全必须获取一个信号量，一旦关键代码完成，线程必须释放信号量。其他想要进入该关键代码段的线程必须等待第一个线程释放该信号量。</h6><h6 id="信号量和互斥量的区别"><a href="#信号量和互斥量的区别" class="headerlink" title="信号量和互斥量的区别"></a>信号量和互斥量的区别</h6></li>
<li>互斥量用于线程的互斥，信号量用于线程的同步</li>
<li>互斥量值只能为0/1，信号量值可以为非负整数。信号量可以实现多个同类线程的互斥和同步</li>
<li>互斥量的加锁和解锁必须由同一线程分别对应使用，信号量可以由一个线程释放，一个线程得到<br>简单的信号量实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Semaphore &#123;</span><br><span class="line">private boolean signal = false;   //使用signal可以避免信号丢失</span><br><span class="line">public synchronized void take() &#123;</span><br><span class="line">    this.signal = true;</span><br><span class="line">    this.notify();</span><br><span class="line">&#125;</span><br><span class="line">public synchronized void release() throws InterruptedException&#123;</span><br><span class="line">    while(!this.signal) //使用while避免假唤醒</span><br><span class="line">        wait();</span><br><span class="line">    this.signal = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>使用场景<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = new Semaphore();</span><br><span class="line">SendingThread sender = new SendingThread(semaphore)；</span><br><span class="line">ReceivingThread receiver = new ReceivingThread(semaphore);</span><br><span class="line">receiver.start();</span><br><span class="line">sender.start();</span><br><span class="line"></span><br><span class="line">public class SendingThread &#123;</span><br><span class="line">    Semaphore semaphore = null;</span><br><span class="line">    public SendingThread(Semaphore semaphore)&#123;</span><br><span class="line">        this.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            //do something, then signal</span><br><span class="line">            this.semaphore.take();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class RecevingThread &#123;</span><br><span class="line">    Semaphore semaphore = null;</span><br><span class="line">    public ReceivingThread(Semaphore semaphore)&#123;</span><br><span class="line">        this.semaphore = semaphore;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">        this.semaphore.release();</span><br><span class="line">        //receive signal, then do something...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>引用自<a href="https://www.jianshu.com/p/c71840db31d2" target="_blank" rel="noopener">https://www.jianshu.com/p/c71840db31d2</a></p>
<h6 id="CAS：Compare-and-Swap"><a href="#CAS：Compare-and-Swap" class="headerlink" title="CAS：Compare and Swap"></a>CAS：Compare and Swap</h6><p>字面比较然后交换<br>java.util.concurrent包中借助CAS实现了区别于Sychronized同步锁的一种乐观锁<br>    compare and swap，无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。<br>    CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。<br>    CAS的语义是我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的实际值为多少。<br>    当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。拿当前对象的值和底层的值进行对比，直到对象的值和底层的值一样时才执行对应的操作，不一样就一直取最新的值。<br>CAS死循环内不断尝试修改目标值直到修改成功，如果竞争不激烈修改成功概率很高。竞争激烈的时候失败率很高，不断尝试会影响性能。<br>对于普通double、long类型，JVM允许64位读操作或写操作拆分为2个32位的操作</p>
<h6 id="wait、sleep、notify、notifyAll"><a href="#wait、sleep、notify、notifyAll" class="headerlink" title="wait、sleep、notify、notifyAll"></a>wait、sleep、notify、notifyAll</h6><p>wait：使一个线程进入等待（阻塞状态），并且释放所持有的对象的锁<br>sleep：使一个正在运行的线程进入睡眠状态，是一个静态方法，调用此方法要处理InterruptException<br>notify：唤醒一个处于等待状态的线程，但是具体唤醒哪一个则不确定，完全取决于JVM<br>notifyAll：唤醒所有等待中的线程，该方法不是把对象的锁还给线程而是让他们竞争，只有获得锁的线程才能进入就绪状态</p>
<h6 id="wait和sleep的区别"><a href="#wait和sleep的区别" class="headerlink" title="wait和sleep的区别"></a>wait和sleep的区别</h6><ul>
<li>sleep来自Thread类，而wait来自Object类</li>
<li>调用sleep不会释放对象锁，而调用wait会释放</li>
<li>sleep调用之后不会出让系统资源，而调用wait后让出系统资源让其他线程可以占用CPU</li>
<li>sleep需要指定一个时间，时间一到自动唤醒<h5 id="原子性-Atomic包"><a href="#原子性-Atomic包" class="headerlink" title="原子性-Atomic包"></a>原子性-Atomic包</h5></li>
<li>atomic包：核心就是CAS，使用的是Unsafe类用的compareAndSafeInt方法（CAS），其实就是将当前值和期望值（底层值）相同，才赋值，否则就一直循环。CAS缺点就是在一个死循环中尝试着修改值，竞争不激烈修改很高，当竞争高，效率下降。对于普通long，double类型，JVM允许64位读操作或写操作拆成2个32位的操作 </li>
<li><em><u><strong>JDK8增加了LongAdder类，在AtomicLong的基础上将单点的更新压力分散到各个节点，在低并发的时候通过对base直接更新很好保障和AtomicLong一样，高并发通过分散提高了性能，缺点是统计时可能会有误差。（优先用）</strong></u></em></li>
<li>compareAndSet常用于AtomicBoolean，希望某件事执行一次</li>
<li>AtomicReference和AtomicIntegerFieldUpdater原子性去更新某个类的实例的某一个字段（volatile，不能是static）</li>
<li>AtomicStampReference:解决的是CAS的ABA问题，加了个版本号来区别。<h6 id="LongAdder的实现思想：热点数据分离。把atomicLong-value分离为数组，每个线程访问时通过hash等算法映射到其中一个数组计数，最终的计数结果是数组的求和累加，热点数据value就被分离成多个单元，提高了并行度。高并发分散提高性能，但准确度会有偏差。"><a href="#LongAdder的实现思想：热点数据分离。把atomicLong-value分离为数组，每个线程访问时通过hash等算法映射到其中一个数组计数，最终的计数结果是数组的求和累加，热点数据value就被分离成多个单元，提高了并行度。高并发分散提高性能，但准确度会有偏差。" class="headerlink" title="LongAdder的实现思想：热点数据分离。把atomicLong value分离为数组，每个线程访问时通过hash等算法映射到其中一个数组计数，最终的计数结果是数组的求和累加，热点数据value就被分离成多个单元，提高了并行度。高并发分散提高性能，但准确度会有偏差。"></a>LongAdder的实现思想：热点数据分离。把atomicLong value分离为数组，每个线程访问时通过hash等算法映射到其中一个数组计数，最终的计数结果是数组的求和累加，热点数据value就被分离成多个单元，提高了并行度。高并发分散提高性能，但准确度会有偏差。</h6><h6 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h6></li>
<li>Synchronize：依赖JVM，作用对象的作用范围内，都是同一时刻只有一个线程操作的</li>
<li>Lock：依赖特殊的CPU指令，代码实现，ReentrankLock<h6 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h6></li>
<li>修饰代码块：大括号括起来的代码，作用于调用的对象</li>
<li>修饰方法：整个方法，作用于调用的对象</li>
<li>修饰静态方法：整个静态方法，作用于所用对象</li>
<li>修饰类：括号括起来的部分，作用于所有对象<br>前两个锁的是当前对象，当多个对象则互不影响。<br>当前类是父类，子类继承父类的Synchronized方法是不带synchronized关键字的，必须自己加上<h6 id="原子性对比"><a href="#原子性对比" class="headerlink" title="原子性对比"></a>原子性对比</h6></li>
<li>synchronized：不可中断所，适用竞争不激烈，可读性好</li>
<li>Lock：可中断锁，多样化同步，竞争激烈时能维持常态</li>
<li>Atomic：竞争激烈时能维持常态，比Lock性能好，只能同步一个值<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><h6 id="导致共享变量在线程内不可见的原因"><a href="#导致共享变量在线程内不可见的原因" class="headerlink" title="导致共享变量在线程内不可见的原因"></a>导致共享变量在线程内不可见的原因</h6></li>
</ul>
<ol>
<li>线程交叉执行</li>
<li>重排序</li>
<li>共享变量更新后的值没有及时在主内存刷新及工作空间<h6 id="可见性-Synchronize"><a href="#可见性-Synchronize" class="headerlink" title="可见性-Synchronize"></a>可见性-Synchronize</h6></li>
<li>线程解锁前，必须将共享变量的最新值刷新到主内存中</li>
<li>线程加锁时，清空工作内存中共享变量的值，使用共享变量时需要到主内存读取最新的值<h6 id="可见性-volatile"><a href="#可见性-volatile" class="headerlink" title="可见性-volatile"></a>可见性-volatile</h6></li>
<li>对volatile变量写操作时，会在写操作后加入一条store屏障命令，将本地内存中的共享变量值刷新到主内存</li>
<li><p>对volatile变量读操作时，会在读操作前加入一条load屏障操作，从主内存读取共享变量<br><img src="evernotecid://D7D93712-3C2E-4EC3-AA0B-D1A7842C2B81/appyinxiangcom/21861001/ENResource/p180" alt="f4ff6f5e58a7acd0b52fd26344ca35d9.png"><br><img src="evernotecid://D7D93712-3C2E-4EC3-AA0B-D1A7842C2B81/appyinxiangcom/21861001/ENResource/p183" alt="354cba5555465ff642e79375808a684e.png"><br><strong><em>注：volatile执行count操作是不安全的，没有原子性。常用于状态标记量</em></strong><br>volatile使用条件<br>对变量的写操作不依赖于当前值<br>该变量没有包含在具有其他变量的不变式子中<br>适用于状态标记量和双重检测（单例模式）</p>
<h6 id="有序性-happens-before"><a href="#有序性-happens-before" class="headerlink" title="有序性 happens-before"></a>有序性 happens-before</h6><h6 id="Synchronized和volatile的区别"><a href="#Synchronized和volatile的区别" class="headerlink" title="Synchronized和volatile的区别"></a>Synchronized和volatile的区别</h6></li>
<li><p>粒度不同，前者针对变量 ，后者锁对象和类</p>
</li>
<li>syn阻塞，volatile线程不阻塞</li>
<li>syn保证三大特性，volatile不保证原子性</li>
<li>syn编译器优化，volatile不优化<br> 要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件： <ol>
<li>对变量的写操作不依赖于当前值。</li>
<li>该变量没有包含在具有其他变量的不变式中。</li>
</ol>
</li>
</ol>
<h6 id="Synchronized和Lock的区别"><a href="#Synchronized和Lock的区别" class="headerlink" title="Synchronized和Lock的区别"></a>Synchronized和Lock的区别</h6><p>ReentrantLock 拥有Synchronized相同的并发性和内存语义，此外还多了 锁投票，定时锁等候和中断锁等候<br>线程A和B都要获取对象O的锁定，假设A获取了对象O锁，B将等待A释放对O的锁定，<br>如果使用 synchronized ，如果A不释放，B将一直等下去，不能被中断<br>如果 使用ReentrantLock，如果A不释放，可以使B在等待了足够长的时间以后，中断等待，而干别的事情</p>
<p>ReentrantLock获取锁定与三种方式： </p>
<ol>
<li>a) lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁 </li>
<li>tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false</li>
<li>tryLock(long timeout,TimeUnit unit)， 如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false</li>
<li>lockInterruptibly:如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断<br>synchronized：<br>在资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。原因在于，编译程序通常会尽可能的进行优化synchronized，另外可读性非常好，不管用没用过5.0多线程包的程序员都能理解。<br>ReentrantLock:<br>ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。在资源竞争不激烈的情形下，性能稍微比synchronized差点点。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。<br><a href="https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1" target="_blank" rel="noopener">https://blog.csdn.net/u012403290/article/details/64910926?locationNum=11&amp;fps=1</a><br><img src="evernotecid://D7D93712-3C2E-4EC3-AA0B-D1A7842C2B81/appyinxiangcom/21861001/ENResource/p182" alt="6cf66d2003e2952acfea9ea356b943c3.png"></li>
</ol>
<h6 id="顺便讲一下Synchronized"><a href="#顺便讲一下Synchronized" class="headerlink" title="顺便讲一下Synchronized"></a>顺便讲一下Synchronized</h6><ol>
<li>作用于方法时，锁住的是对象的实例(this)；</li>
<li>当作用于静态方法时，锁住的是Class实例，又因为Class的相关数据存储在永久带PermGen（jdk1.8则是metaspace），永久带是全局共享的，因此静态方法锁相当于类的一个全局锁，会锁所有调用该方法的线程；</li>
<li>synchronized作用于一个对象实例时，锁住的是所有以该对象为锁的代码块。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>原子性：CAS，Synchronize，Lock，互斥访问，Atomic<br>可见性：volatile，Synchronize<br>有序性：as-if-serial，happens-before</p>
<h5 id="安全发布对象"><a href="#安全发布对象" class="headerlink" title="安全发布对象"></a>安全发布对象</h5><ol>
<li>在静态初始化函数中初始化一个对象引用</li>
<li>将对象的引用保存到volatile类型域或AtomicReference对象中</li>
<li>将对象的引用保存到某个正确构造对象的final类型域中</li>
<li>将对象的引用保存到一个锁保护的域中</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/07/test-blog/" data-id="ck3zb2vf600053l3p4arsn1r4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/07/hello-world/" class="article-date">
  <time datetime="2019-04-06T17:28:49.426Z" itemprop="datePublished">2019-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/07/hello-world/" data-id="ck3zb2vet00013l3pw9sge5s5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/12/10/test-blog-1/">test_blog</a>
          </li>
        
          <li>
            <a href="/2019/04/15/BeanFactory和FactoryBean、ApplicationContext的区别/">BeanFactory和FactoryBean、ApplicationContext的区别</a>
          </li>
        
          <li>
            <a href="/2019/04/11/工厂模式/">工厂模式</a>
          </li>
        
          <li>
            <a href="/2019/04/10/静态代理、JDK动态代理、CgLib动态代理/">静态代理、JDK动态代理、CgLib动态代理</a>
          </li>
        
          <li>
            <a href="/2019/04/08/java内存模型JMM/">java内存模型JMM</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>